## <div align="center">编译系统设计实验</div>

### <div align="right">3150102103 肖  潼</div>

### <div align="right">3150104532 周佳瑜</div>

### <div align="right">3150104790 李天幼</div>

### <div align="center">设计目的</div>

设计并实现一个类C语言的编译系统，掌握编译原理的各个环节：词法分析、语法分析、语义分析、代码生成，以及实现所需的数据结构：语法书、符号表等。

### <div align="center">系统目标</div>

类C语言编译系统将会实现以下功能：

* 根据C语言标准文件 `Anti.C.Standard.pdf`，实现C语言所有的词法分析

* 根据C语言标准文件 `Anti.C.Standard.pdf`，实现C语言所有的语法分析

* 实现部分C语言的语义分析，生成中间树结构

* 分析生成的中间树，根据MIPS标准文件 `MIPS_Vol2.pdf`，生成MIPS汇编代码

### <div align="center">过程分析</div>

我们将整个类C语言编译系统分为以下几个步骤：

* lex词法分析

* yacc语法分析

* 生成抽象语法树

* 语义分析以及生成符号表

* 翻译为中间树以及处理

* 活跃性分析以及寄存器分配

* 指令选择以及翻译

下面我们将根据整个编译系统的设计顺序，介绍系统中每个模块的实现以及功能。

#### lex词法分析

我们设计的类C语言词法分析严格按照C语言标准，参照了C语言标准文档 `Anti.C.Standard.pdf`。

根据标准文档的分类，C语言词法主要分为以下几类：

1. keyword
    
    关键字共有37个，包含了常用的关键字比如 *auto*，*const* 等，以及不常用的关键字比如 *volatile*，*_Complex* 等

2. identifier

    标识符是由字母或下划线开头，包含字母，下划线或数字的任意长度的字符串，它的正则表达式为： `[a-zA-Z_][a-zA-Z0-9_]*`

3. constant

    常量类包含了6种常量：

    * 十进制整数
    * 八进制整数
    * 十六进制整数
    * 十进制浮点数
    * 十六进制浮点数
    * 字符常量

4. string-literal

    为了设计方便，字符串与其他常量划分为不同类，他是以 `L` 开头，被双引号包围的字符串，其中开头的 `L` 可以省略。
    
    它的正则表达式为：`L?\"([^\"\\\n]|(\\[\'\"\?\\abfnrtv]))*\"`

5. punctuator

    符号类包含了所有的运算或标识符，包含了例如运算符 `+`、`%`，或逻辑运算符 `&&`，`!`等

6. others

    其他符号类包含了一些没有运算层面含义的符号，比如 `\n`，`\\`等用于换行或标识的符号，其中用于匹配非法字符的 `.`，即 *default*，也定义在该类中

在词法分析这一步，我们使用的工具是更为现代的 *flex* 工具。

#### yacc语法分析

在语法分析这一步，我们的类C语言编译系统能够解析出所有C语言标准中的语法，我们严格按照C语言标准文档 `Anti.C.Standard.pdf`进行设计。

整个语法分析过程中使用了80余个 *token*， 一共能够解析69个语法，每个语法有多种解析格式，整个yacc语法分析文件有440余行，能够C语言中所有语法。

在语法分析这衣服，我们使用的工具是更为现代的 *bison* 工具。

#### 生成抽象语法树

这一部分对应的代码是 *absync* 和 *symbol* 部分，这部分的主要功能是将上一步解析出的C语言语法，进一步加以解析，生成逻辑更为清晰的抽象语法树。

在这一步，我们实现了C语言标准中的所有语法，根据

我们按照C语言标准文档将抽象语法树中的节点分类：

1. Exp

2. Spec

3. Type

4. Pointer

5. Param

6. Dec

7. Declaration

8. Type_name

9. Designator

10. Init

11. Stat

12. Def

整个模块代码生成一棵AST树，并且经由测试模块 *testAST* 可以将生成的树状结构输出，例如C语言代码如下：

![](AST.png)

该代码会被转为如下的AST树结构

![](ASTres.png)

#### 语义分析以及生成符号表

该部分的主要功能是，通过解析上一步生成的AST树，进行语义分析，判断是否有语法上的错误，例如如下代码：

    float x = 10.0;
    ++ x;

该代码在语法分析和生成抽象语法树的部分都不会出现错误，因为 `x` 是一个变量，而运算符 `++` 在yacc文件中的定义如下：

    unary_expression:
        DOUBLE_PLUS unary_expression      {$$ = _A_prepp_exp(charPos, $2);}

这一步并不会导致语法错误，而在语义层面上，浮点数变量不能进行 `++` 运算，这需要在语义分析中进行分析。

同时，在分析语义的过程中，我们还需要创立符号表。符号表存储着所有的变量，函数等，表中存储着该符号所表达的含义，比如变量所属的类型，自定义类型，如 `struct`，`union` 的构成方式等。

因为整个C语言的结构过于复杂，我们很难独立实现整个语言的语义分析和符号表表示，因此我们在这一步，对C语言进行了简化，只保留了部分功能。

//TODO 保留了什么？

这一部分的代码在模块 *semant*， *table* 中。

#### 翻译为中间树以及处理

抽象语法树虽然易于从代码中翻译出来，但是并不能够直接翻译成最终的汇编代码，我们需要将AST翻译为更加通用的中间代码树。

从这一过程开始，编译系统已经有了十分成熟的工具，C++语言库 *llvm*，该工具能够帮助编译器开发者自动生成中间代码树，并接手中间代码树之后的所有工作，直到生成可执行程序。但是我们小组想要更好地理解从IR树到生成最终代码的过程。因此，我们并没有选择使用 *llvm* 工具，而是自己实现了接下来的每一步。

AST是C语言代码的树结构抽象，而IR树则更接近于整个代码的实际运算，它包含 `T_stm` 和 `T_exp` 两种类型的节点。

其中，`T_stm`类型节点保存着代码的执行状态信息，比如 `SEQ`，`JUMP`，`LABEL`等信息。而`T_exp`类型节点则保存的是运算类型的信息，比如`BINOP`，`CONST`，`ESEQ`。这两类节点组成的IR树，能够准确表达任何程序所做的工作，并且更接近底层的汇编代码。

在翻译为中间树后，我们还需要将IR树进一步处理，转化Canon树表示。Canon树以IR树为基础改进的数据结构，它是一个由链表串联起来的森林，森林中的每棵树的 `LABEL` 都放置在树的前序遍历最小的节点上，并且跳转语句代表的节点都放置在树的前序遍历最大的节点上。IR树种的`ESEQ`被`SEQ`完全取代，而`SEQ`所代表的顺序关系，又被Canon树中的链表所表示。

该部分代码在模块 *tree* 和 *Canon* 中。

#### 活跃性分析以及寄存器分配

在IR树和Canon树中，我们默认CPU中有无限多的寄存器，这样我们可以申请任意多的临时寄存器，来存储我们的变量。然而，在实际情况中，寄存器的数量都是有限的，可以提供给运行程序的寄存器更加稀缺，当我们需要使用一个变量的时候，要么它在寄存器中，要么我们需要从内存中将该变量读取到寄存器中，这个操作消耗更多的时间。

活跃性分析就是分析变量在代码的哪些位置是活跃的，也就是需要被使用的。分析出这些信息后，我们可以构建临时变量的冲突图，并在冲突图上运行图染色算法，从而获得较优，甚至最优的寄存器分配方案，这个方案能够让我们的程序在运行时，花费较少的时间在无意义的数据IO操作上。

该部分的代码在模块 *temp* 和 *map* 中。

#### 指令选择以及翻译

这是部分是整个编译系统中最后一个部分，我们在得到了接近汇编代码的Canon树和寄存器分配方案后，通过对Canon树进行解析，从而获得最后的MIPS汇编代码。

然而，Canon树的解析方案可能有很多种，我们可以使用动态规划算法，得到需要指令数最少的翻译方案，从而获得高效的MIPS汇编代码。

该部分的代码在模块 *inst* 中。

### <div align="center">总结</div>

在这次编译原理课程实验中，我们小组实现了一个类C语言的编译系统。

在整个系统的前半部分，直到AST的生成，也就是前端部分，我们按照C语言标准文档，`Anti.C.Standard.pdf`，完全实现了C语言的所有语法。

在系统的后半部分，从生成IR树到生成MIPS汇编代码的部分，也就是后端部分，我们选择了C语言的一些基本功能并加以实现，最终按照MIPS架构标准文档，生成了MIPS汇编代码。

整个项目挂载于开源项目网站Github上，项目名称为 [CCompiler](https://github.com/greyring/CCompiler)。

